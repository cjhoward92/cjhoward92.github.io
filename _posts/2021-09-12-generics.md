---
layout: post
title:  Generics
date:   2021-09-12 13:00:00
description: What exactly are generics and why should we use them?
categories: microblog
tags: learning generics programming
---

Generics aren't daunting because of what they are but because of how complicated they get. Breaking them into concrete implementations and renaming type variables can help.

## What are they?

A generic type is one that allows a developer to build general functionality not bound to a specific type. The generic type defines what other types can be used with it.
Here is an example of a simple collection generic that allows any type in the type variable:

{% highlight typescript %}
// <T> signals that this type is generic. It's called the type variable.
class Collection<T> {

  private items: Array<T> = [];

  constructor() {}

  getAt(index: number): T {
    return this.items[index];
  }
  add(item: T): void {
    this.items.push(item);
  }
  removeAt(index: number): void {
    this.items = this.items.splice(index, 0);
  }
  count(): number {
    return this.items.length;
  }
}
{% endhighlight %}

## Why are they hard?

I think the "difficulty" in generics comes from bad generic type variable naming or overly complex types. You usually see type variables names `T` or `U` (like in my example above). Would you name a regular variable `T`? No, you wouldn't. So why name a type variable that way?

{% highlight typescript %}
class Collection<TCollectedType> {

  private items: Array<TCollectedType> = [];

  constructor() {}

  getAt(index: number): TCollectedType {
    return this.items[index];
  }
  add(item: TCollectedType): void {
    this.items.push(item);
  }
  removeAt(index: number): void {
    this.items = this.items.splice(index, 0);
  }
  count(): number {
    return this.items.length;
  }
}
{% endhighlight %}

`TCollectedType` is more explicit. It calls out the `T` type variable as something it actually is: a type collected by the collection (you don't need to prefix with `T` but that's pretty common to signal a type variable).

Here is how we use of the above type with the `TCollectedType` as `string`:

{% highlight typescript %}
const stringCollection = new Collection<string>();
{% endhighlight %}

Most languages with generics allow developers to limit what types can be used in the generic. This is useful when you want a generic, but the types that can be used with it require specific attributes.

## Why do we use generics?

We use them to save code, primarily. You don't need to change the collection code above regardless of the type you use as `TCollectedType`. A string only collection would look like:

{% highlight typescript %}
class Collection {

  private items: Array<string> = [];

  constructor() {}

  getAt(index: number): string {
    return this.items[index];
  }
  add(item: string): void {
    this.items.push(item);
  }
  removeAt(index: number): void {
    this.items = this.items.splice(index, 0);
  }
  count(): number {
    return this.items.length;
  }
}
{% endhighlight %}

It's clear that code isn't specific to strings. With generics you can share the code without re-implementing anything.

{% highlight typescript %}
const stringCollection = new Collection<string>();
const numberCollection = new Collection<number>();
const objectCollection = new Collection<Object>();
{% endhighlight %}

[Here is an example on repl.it](https://replit.com/@cjhoward92/Generics).

## What's next?

- [Typescript docs on generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [Oracle's explanation of generics in Java](https://www.oracle.com/technical-resources/articles/java/juneau-generics.html)
- [More reasons to use generics (in Java, again)](https://docs.oracle.com/javase/tutorial/java/generics/why.html)
